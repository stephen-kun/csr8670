// Constants needed for API and internally
// Beamformer
.CONST $M.BEAMFORMER.BIN_L             2;
.CONST $M.BEAMFORMER.BIN_H             63;
.CONST $M.BEAMFORMER.PROCESSING_BINS   ($M.BEAMFORMER.BIN_H - $M.BEAMFORMER.BIN_L + 1);

// AED
.CONST $M.AED.BIN_L           5;
.CONST $M.AED.BIN_H           59;
.CONST $M.AED.IDX_PROC        ($M.AED.BIN_H - $M.AED.BIN_L + 1);
.CONST $M.AED.IDX_PROC_INV    0x0253C8; // = 1/55 Q23

// Two Channel Noise Canceller
.CONST $M.TWOCHANNEL_NC.BIN_L             5;
.CONST $M.TWOCHANNEL_NC.BIN_H             59;
.CONST $M.TWOCHANNEL_NC.NC_num_proc       ($M.TWOCHANNEL_NC.BIN_H - $M.TWOCHANNEL_NC.BIN_L + 1);
.CONST $M.TWOCHANNEL_NC.Num_Taps          2;

.CONST $M.BEAMFORMER.OFFSET_X0_REAL_PTR      0;
.CONST $M.BEAMFORMER.OFFSET_X0_IMAG_PTR      $M.BEAMFORMER.OFFSET_X0_REAL_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_BEXP_X0_PTR      $M.BEAMFORMER.OFFSET_X0_IMAG_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_X1_REAL_PTR      $M.BEAMFORMER.OFFSET_BEXP_X0_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_X1_IMAG_PTR      $M.BEAMFORMER.OFFSET_X1_REAL_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_BEXP_X1_PTR      $M.BEAMFORMER.OFFSET_X1_IMAG_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_Z_REAL_PTR       $M.BEAMFORMER.OFFSET_BEXP_X1_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_Z_IMAG_PTR       $M.BEAMFORMER.OFFSET_Z_REAL_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_MU_PTR           $M.BEAMFORMER.OFFSET_Z_IMAG_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_BEAM_MODE        $M.BEAMFORMER.OFFSET_MU_PTR + 1;
.CONST $M.BEAMFORMER.OFFSET_ELEMENT_D        $M.BEAMFORMER.OFFSET_BEAM_MODE + 1;
.CONST $M.BEAMFORMER.OFFSET_DOA              $M.BEAMFORMER.OFFSET_ELEMENT_D + 1;
.CONST $M.BEAMFORMER.OFFSET_PTR_DM1data      $M.BEAMFORMER.OFFSET_DOA + 1;
.CONST $M.BEAMFORMER.OFFSET_SCRATCH_DM1  	   $M.BEAMFORMER.OFFSET_PTR_DM1data + 1;
.CONST $M.BEAMFORMER.OFFSET_SCRATCH_DM2  	   $M.BEAMFORMER.OFFSET_SCRATCH_DM1 + 1;
.CONST $M.BEAMFORMER.STRUC_SIZE              $M.BEAMFORMER.OFFSET_SCRATCH_DM2 + 1;

// 2Mic HF object
.CONST $M.TWOMIC_HF_500.OFFSET_CONFIG              0;
.CONST $M.TWOMIC_HF_500.OFFSET_MIC_MODE            $M.TWOMIC_HF_500.OFFSET_CONFIG + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_MGDC_CTRL           $M.TWOMIC_HF_500.OFFSET_MIC_MODE + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_BF0_PTR             $M.TWOMIC_HF_500.OFFSET_MGDC_CTRL + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_BF1_PTR             $M.TWOMIC_HF_500.OFFSET_BF0_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_2MICAEC_PTR         $M.TWOMIC_HF_500.OFFSET_BF1_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_AED_PTR             $M.TWOMIC_HF_500.OFFSET_2MICAEC_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_2CHNC_PTR           $M.TWOMIC_HF_500.OFFSET_AED_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_OMS_IN_PTR          $M.TWOMIC_HF_500.OFFSET_2CHNC_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_OMS_OUT0_PTR        $M.TWOMIC_HF_500.OFFSET_OMS_IN_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_OMS_OUT1_PTR        $M.TWOMIC_HF_500.OFFSET_OMS_OUT0_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_NUM_BINS            $M.TWOMIC_HF_500.OFFSET_OMS_OUT1_PTR + 1;
// Inputs
.CONST $M.TWOMIC_HF_500.OFFSET_X0_REAL_PTR         $M.TWOMIC_HF_500.OFFSET_NUM_BINS + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_X0_IMAG_PTR         $M.TWOMIC_HF_500.OFFSET_X0_REAL_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_BEXP_X0_PTR         $M.TWOMIC_HF_500.OFFSET_X0_IMAG_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_X1_REAL_PTR         $M.TWOMIC_HF_500.OFFSET_BEXP_X0_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_X1_IMAG_PTR         $M.TWOMIC_HF_500.OFFSET_X1_REAL_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_BEXP_X1_PTR         $M.TWOMIC_HF_500.OFFSET_X1_IMAG_PTR+ 1;
// Outputs
.CONST $M.TWOMIC_HF_500.OFFSET_Z0_REAL_PTR         $M.TWOMIC_HF_500.OFFSET_BEXP_X1_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_Z0_IMAG_PTR         $M.TWOMIC_HF_500.OFFSET_Z0_REAL_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_Z1_REAL_PTR         $M.TWOMIC_HF_500.OFFSET_Z0_IMAG_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_Z1_IMAG_PTR         $M.TWOMIC_HF_500.OFFSET_Z1_REAL_PTR + 1;
// Variables for Power Monitoring
.CONST $M.TWOMIC_HF_500.OFFSET_TMP_LalfaLPz_PTR    $M.TWOMIC_HF_500.OFFSET_Z1_IMAG_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_TMP_LPin0_PTR       $M.TWOMIC_HF_500.OFFSET_TMP_LalfaLPz_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_TMP_LPin1_PTR       $M.TWOMIC_HF_500.OFFSET_TMP_LPin0_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_TMP_LPout0_PTR      $M.TWOMIC_HF_500.OFFSET_TMP_LPin1_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_TMP_LPout1_PTR      $M.TWOMIC_HF_500.OFFSET_TMP_LPout0_PTR + 1;
.CONST $M.TWOMIC_HF_500.OFFSET_PTR_DM1data         $M.TWOMIC_HF_500.OFFSET_TMP_LPout1_PTR + 1;
.CONST $M.TWOMIC_HF_500.STRUC_SIZE                 $M.TWOMIC_HF_500.OFFSET_PTR_DM1data + 1;

// @DATA_OBJECT MIC1AECDATAOBJECT
// Below must match AEC
// @DOC_FIELD_TEXT Internal
.CONST $M.TWOMIC_AEC.OFFSET_FNLMS_E_REAL_PTR             0;
// @DOC_FIELD_TEXT Internal
.CONST $M.TWOMIC_AEC.OFFSET_FNLMS_E_IMAG_PTR             $M.TWOMIC_AEC.OFFSET_FNLMS_E_REAL_PTR+1;
// @DOC_FIELD_TEXT Internal
.CONST $M.TWOMIC_AEC.OFFSET_FNLMS_D_EXP_PTR              $M.TWOMIC_AEC.OFFSET_FNLMS_E_IMAG_PTR+1;
// @DOC_FIELD_TEXT Internal
.CONST $M.TWOMIC_AEC.OFFSET_FNLMS_D_REAL_PTR             $M.TWOMIC_AEC.OFFSET_FNLMS_D_EXP_PTR+1;
// @DOC_FIELD_TEXT Internal
.CONST $M.TWOMIC_AEC.OFFSET_FNLMS_D_IMAG_PTR             $M.TWOMIC_AEC.OFFSET_FNLMS_D_REAL_PTR+1;
// @DOC_FIELD_FORMAT Pointer
// @DOC_FIELD_TEXT Pointer to a scratch memory in DM2 with size of '2*$M.adf_alg_1_0_0.ADF_num_proc + 1'
.CONST $M.TWOMIC_AEC.OFFSET_FNLMS_SCRPTR_Exp_Mts_adapt   $M.TWOMIC_AEC.OFFSET_FNLMS_D_IMAG_PTR + 1;
// End Match
.CONST $M.TWOMIC_AEC.OFFSET_PTR_MAIN_AEC                 $M.TWOMIC_AEC.OFFSET_FNLMS_SCRPTR_Exp_Mts_adapt + 1;
.CONST $M.TWOMIC_AEC.OFFSET_PTR_BYPASS_AEC1              $M.TWOMIC_AEC.OFFSET_PTR_MAIN_AEC + 1;
.CONST $M.TWOMIC_AEC.OFFSET_PTR_Ga_real                  $M.TWOMIC_AEC.OFFSET_PTR_BYPASS_AEC1 + 1;
.CONST $M.TWOMIC_AEC.OFFSET_PTR_Ga_imag                  $M.TWOMIC_AEC.OFFSET_PTR_Ga_real + 1;
.CONST $M.TWOMIC_AEC.OFFSET_PTR_BExp_Ga                  $M.TWOMIC_AEC.OFFSET_PTR_Ga_imag + 1;
.CONST $M.TWOMIC_AEC.OFFSET_PTR_RcvBuf_real              $M.TWOMIC_AEC.OFFSET_PTR_BExp_Ga + 1;
.CONST $M.TWOMIC_AEC.OFFSET_PTR_RcvBuf_imag              $M.TWOMIC_AEC.OFFSET_PTR_RcvBuf_real + 1;
// Size of the block
.CONST $M.TWOMIC_AEC.STRUCT_SIZE                         $M.TWOMIC_AEC.OFFSET_PTR_RcvBuf_imag + 1;
// @END  DATA_OBJECT MIC1AECDATAOBJECT

.CONST $M.AED.OFFSET_G_OMS0               0;
.CONST $M.AED.OFFSET_VOICED_OMS0          $M.AED.OFFSET_G_OMS0 + 1;
.CONST $M.AED.OFFSET_G_OMS1               $M.AED.OFFSET_VOICED_OMS0 + 1;
.CONST $M.AED.OFFSET_VOICED_OMS1          $M.AED.OFFSET_G_OMS1 + 1;
.CONST $M.AED.OFFSET_VOICEFLAG            $M.AED.OFFSET_VOICED_OMS1 + 1;
.CONST $M.AED.OFFSET_MODE                 $M.AED.OFFSET_VOICEFLAG + 1;
.CONST $M.AED.OFFSET_STATE_T              $M.AED.OFFSET_MODE + 1;
.CONST $M.AED.OFFSET_VAD                  $M.AED.OFFSET_STATE_T + 1;
.CONST $M.AED.OFFSET_CHANNEL              $M.AED.OFFSET_VAD + 1;
.CONST $M.AED.OFFSET_G_AED                $M.AED.OFFSET_CHANNEL + 1;
.CONST $M.AED.OFFSET_Noise_Th             $M.AED.OFFSET_G_AED + 1;
.CONST $M.AED.OFFSET_alphaA               $M.AED.OFFSET_Noise_Th + 1;
.CONST $M.AED.OFFSET_alphaN               $M.AED.OFFSET_alphaA + 1;
.CONST $M.AED.OFFSET_NR_defer_Count       $M.AED.OFFSET_alphaN + 1;
.CONST $M.AED.OFFSET_NR_max_Count         $M.AED.OFFSET_NR_defer_Count + 1;
.CONST $M.AED.OFFSET_NR_alpha             $M.AED.OFFSET_NR_max_Count + 1;
.CONST $M.AED.OFFSET_S_ACTIVE_COUNT       $M.AED.OFFSET_NR_alpha + 1;
.CONST $M.AED.OFFSET_S_ACTIVE_COUNT_DIV_6 $M.AED.OFFSET_S_ACTIVE_COUNT + 1;
.CONST $M.AED.OFFSET_PTR_DM1data          $M.AED.OFFSET_S_ACTIVE_COUNT_DIV_6 + 1;
.CONST $M.AED.STRUC_SIZE                  $M.AED.OFFSET_PTR_DM1data + 1;

// Below must match AEC
.CONST $M.TWOCHANNEL_NC.OFFSET_E_REAL_PTR             0;
.CONST $M.TWOCHANNEL_NC.OFFSET_E_IMAG_PTR             $M.TWOCHANNEL_NC.OFFSET_E_REAL_PTR + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_BEXP_D_PTR             $M.TWOCHANNEL_NC.OFFSET_E_IMAG_PTR + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_D_REAL_PTR             $M.TWOCHANNEL_NC.OFFSET_BEXP_D_PTR + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_D_IMAG_PTR             $M.TWOCHANNEL_NC.OFFSET_D_REAL_PTR + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_SCRPTR_Exp_Mts_adapt   $M.TWOCHANNEL_NC.OFFSET_D_IMAG_PTR + 1;
// End Match
.CONST $M.TWOCHANNEL_NC.OFFSET_X_REAL_PTR             $M.TWOCHANNEL_NC.OFFSET_SCRPTR_Exp_Mts_adapt + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_X_IMAG_PTR             $M.TWOCHANNEL_NC.OFFSET_X_REAL_PTR + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_BEXP_X_PTR             $M.TWOCHANNEL_NC.OFFSET_X_IMAG_PTR + 1;
// @DOC_FIELD_TEXT Pointer to OMS G array
// @DOC_FIELD_FORMAT Pointer
.CONST $M.TWOCHANNEL_NC.OFFSET_AED_DIFF_PTR           $M.TWOCHANNEL_NC.OFFSET_BEXP_X_PTR+1;
// @DOC_FIELD_TEXT NC adaptation rate, default 0xFF0000 (-1), Q8.16 (CVC parameter)
// @DOC_FIELD_FORMAT Q8.16
.CONST $M.TWOCHANNEL_NC.OFFSET_PP_GAMMAP              $M.TWOCHANNEL_NC.OFFSET_AED_DIFF_PTR + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_bypass_postp_rpt       $M.TWOCHANNEL_NC.OFFSET_PP_GAMMAP + 1;
.CONST $M.TWOCHANNEL_NC.OFFSET_num_taps               $M.TWOCHANNEL_NC.OFFSET_bypass_postp_rpt + 1;

// Scratch Memory
// LPwrX0 = &$M.AEC_500.dm1.scratch1
// LPwrX1 = &$M.AEC_500.dm1.scratch1 + ADF_num_proc
// LpX1t  = &$M.AEC_500.dm1.scratch1 + 2*ADF_num_proc
// adaptFactor01 = &$M.AEC_500.dm1.scratch1 + 3*ADF_num_proc
// adaptFactor10 = &$M.AEC_500.dm1.scratch1 + 4*ADF_num_proc
// @DOC_FIELD_TEXT Pointer to DM1 scratch block, with size of '$M.TWOCHANNEL_NC.SCRATCH_SIZE_DM1'
// @DOC_FIELD_FORMAT Pointer
.CONST $M.TWOCHANNEL_NC.OFFSET_SCRATCH_DM1  	   $M.TWOCHANNEL_NC.OFFSET_num_taps+1;

// sgn_xdGa01 = &$M.AEC_500.dm2.scratch1
// @DOC_FIELD_TEXT Pointer to DM2 scratch block, with size of '$M.TWOCHANNEL_NC.SCRATCH_SIZE_DM2'
// @DOC_FIELD_FORMAT Pointer
.CONST $M.TWOCHANNEL_NC.OFFSET_SCRATCH_DM2  	   $M.TWOCHANNEL_NC.OFFSET_SCRATCH_DM1+1;

// Buffer Pointers
// @DOC_FIELD_TEXT Pointer to DM1 data block, with size of '$M.adf_alg_1_0_0.DATA_SIZE_DM1'
// @DOC_FIELD_FORMAT Pointer
.CONST $M.TWOCHANNEL_NC.OFFSET_PTR_DM1data      $M.TWOCHANNEL_NC.OFFSET_SCRATCH_DM2+1;
// @DOC_FIELD_FORMAT Pointer
// @DOC_FIELD_TEXT Pointer to DM2 data block, with size of '$M.adf_alg_1_0_0.DATA_SIZE_DM2'
.CONST $M.TWOCHANNEL_NC.OFFSET_PTR_DM2data      $M.TWOCHANNEL_NC.OFFSET_PTR_DM1data+1;


.CONST $M.TWOCHANNEL_NC.STRUC_SIZE              $M.TWOCHANNEL_NC.OFFSET_PTR_DM2data + 1;

.CONST $M.TWOCHANNEL_NC.OFFSET_SCR2PTR_PP_LpXt  $M.TWOCHANNEL_NC.OFFSET_SCRATCH_DM2;


// Internal memory definitions

// AED
// DM1 data offset for AED
.CONST $M.AED.OFFSET_DM1PTR_Diff       $M.AED.OFFSET_PTR_DM1data;
.CONST $M.AED.DM1.Diff                 0;
.CONST $M.AED.DM1.Difft                $M.AED.DM1.Diff + $M.AED.IDX_PROC;
.CONST $M.AED.DM1.AED_control          $M.AED.DM1.Difft + $M.AED.IDX_PROC;
.CONST $M.AED.DM1.state                $M.AED.DM1.AED_control + $M.AED.IDX_PROC;
.CONST $M.AED.DM1.stateCount           $M.AED.DM1.state + 1;
.CONST $M.AED.DM1.stateCountMax        $M.AED.DM1.stateCount + 9;
.CONST $M.AED.DM1.noiseCount           $M.AED.DM1.stateCountMax + 9;
.CONST $M.AED.DATA_SIZE_DM1            $M.AED.DM1.noiseCount + 1;

// 2mic_hf
// DM1 data offset
.CONST $M.TWOMIC_HF_500.OFFSET_DM1_phase_E0        $M.TWOMIC_HF_500.OFFSET_PTR_DM1data;
.CONST $M.TWOMIC_HF_500.DM1.Phase_E0               0;
.CONST $M.TWOMIC_HF_500.DM1.Phase_E1               $M.TWOMIC_HF_500.DM1.Phase_E0 + $M.BEAMFORMER.BIN_H;
.CONST $M.TWOMIC_HF_500.DATA_SIZE_DM1              $M.TWOMIC_HF_500.DM1.Phase_E1 + $M.BEAMFORMER.BIN_H;

// Beamformer
// DM1 data offset
.CONST $M.BEAMFORMER.OFFSET_DM1PTR_CC_real_imag    $M.BEAMFORMER.OFFSET_PTR_DM1data;
.CONST $M.BEAMFORMER.DM1.CC_real_imag              0;
.CONST $M.BEAMFORMER.DM1.Phi_real_imag             $M.BEAMFORMER.DM1.CC_real_imag + 2*$M.BEAMFORMER.PROCESSING_BINS;
.CONST $M.BEAMFORMER.DM1.TR                        $M.BEAMFORMER.DM1.Phi_real_imag + 2*$M.BEAMFORMER.PROCESSING_BINS;
.CONST $M.BEAMFORMER.DATA_SIZE_DM1                 $M.BEAMFORMER.DM1.TR + $M.BEAMFORMER.PROCESSING_BINS;

// Two channel NC
// DM1 data offset
.CONST $M.TWOCHANNEL_NC.OFFSET_DM1PTR_RcvBuf_real  $M.TWOCHANNEL_NC.OFFSET_PTR_DM1data;
.CONST $M.TWOCHANNEL_NC.DM1.RcvBuf_real            0;
.CONST $M.TWOCHANNEL_NC.DM1.Gp_imag                $M.TWOCHANNEL_NC.DM1.RcvBuf_real + $M.TWOCHANNEL_NC.NC_num_proc*$M.TWOCHANNEL_NC.Num_Taps;
.CONST $M.TWOCHANNEL_NC.DM1.LPwrXp                 $M.TWOCHANNEL_NC.DM1.Gp_imag     + $M.TWOCHANNEL_NC.NC_num_proc*$M.TWOCHANNEL_NC.Num_Taps;
.CONST $M.TWOCHANNEL_NC.DM1.BExp_Gp                $M.TWOCHANNEL_NC.DM1.LPwrXp      + $M.TWOCHANNEL_NC.NC_num_proc;
.CONST $M.TWOCHANNEL_NC.DATA_SIZE_DM1              $M.TWOCHANNEL_NC.DM1.BExp_Gp     + $M.TWOCHANNEL_NC.NC_num_proc;

// DM2 data offset
.CONST $M.TWOCHANNEL_NC.OFFSET_DM2PTR_cRcvBuf_imag $M.TWOCHANNEL_NC.OFFSET_PTR_DM2data;
.CONST $M.TWOCHANNEL_NC.DM2.RcvBuf_imag            0;
.CONST $M.TWOCHANNEL_NC.DM2.Gp_real                $M.TWOCHANNEL_NC.DM2.RcvBuf_imag + $M.TWOCHANNEL_NC.NC_num_proc*$M.TWOCHANNEL_NC.Num_Taps;
.CONST $M.TWOCHANNEL_NC.DM2.BExp_X_buf             $M.TWOCHANNEL_NC.DM2.Gp_real     + $M.TWOCHANNEL_NC.NC_num_proc*$M.TWOCHANNEL_NC.Num_Taps;  // wmsn: dBExp_X_buf(Num_Taps) + BExp_X_buf(1) //wmsn: check
.CONST $M.TWOCHANNEL_NC.DATA_SIZE_DM2              $M.TWOCHANNEL_NC.DM2.BExp_X_buf  + $M.TWOCHANNEL_NC.Num_Taps + 1;
